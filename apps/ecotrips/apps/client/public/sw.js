// Generated by scripts/build-sw.mjs on 2025-10-24T09:06:52.948Z
/// <reference lib="webworker" />
const serviceWorker = self;
const BUILD_VERSION = "7c11fd34904b50eea0498cf72ee46ab2c5fe67c3";
const STATIC_CACHE = `static-${BUILD_VERSION}`;
const API_CACHE = `api-${BUILD_VERSION}`;
const INVENTORY_CACHE = `inventory-${BUILD_VERSION}`;
const PRECACHE_MANIFEST = /* __PRECACHE_MANIFEST__ */ [
    {
        "url": "/icons/icon.svg",
        "revision": "7fe9929ce199a514"
    },
    {
        "url": "/manifest.json",
        "revision": "1edc70f724b8f90e"
    }
];
const PRECACHE_URLS = Array.from(new Set(["/", ...PRECACHE_MANIFEST.map((entry) => entry.url)]));
const PRECACHE_URL_SET = new Set(PRECACHE_URLS);
const PRECACHE_REVISION_MAP = new Map(PRECACHE_MANIFEST.map((entry) => [entry.url, entry.revision]));
const RUNTIME_CACHES = [STATIC_CACHE, API_CACHE, INVENTORY_CACHE];
serviceWorker.addEventListener("install", (event) => {
    const swEvent = event;
    serviceWorker.skipWaiting();
    swEvent.waitUntil((async () => {
        const cache = await caches.open(STATIC_CACHE);
        await Promise.all(PRECACHE_URLS.map(async (url) => {
            var _a;
            const request = new Request(url, { cache: "reload" });
            const response = await fetch(request);
            const pathname = new URL(request.url).pathname;
            const revision = (_a = PRECACHE_REVISION_MAP.get(pathname)) !== null && _a !== void 0 ? _a : (pathname === "/" ? BUILD_VERSION : undefined);
            await cache.put(request, stamp(response, { revision }));
        }));
    })());
});
serviceWorker.addEventListener("activate", (event) => {
    const swEvent = event;
    swEvent.waitUntil((async () => {
        const keys = await caches.keys();
        await Promise.all(keys
            .filter((key) => !RUNTIME_CACHES.includes(key))
            .map((key) => caches.delete(key)));
        const staticCache = await caches.open(STATIC_CACHE);
        const cachedRequests = await staticCache.keys();
        await Promise.all(cachedRequests.map(async (request) => {
            var _a;
            const pathname = new URL(request.url).pathname;
            if (!PRECACHE_URL_SET.has(pathname)) {
                await staticCache.delete(request);
                return;
            }
            const expectedRevision = (_a = PRECACHE_REVISION_MAP.get(pathname)) !== null && _a !== void 0 ? _a : (pathname === "/" ? BUILD_VERSION : undefined);
            if (!expectedRevision) {
                return;
            }
            const cachedResponse = await staticCache.match(request);
            const cachedRevision = cachedResponse === null || cachedResponse === void 0 ? void 0 : cachedResponse.headers.get("sw-revision");
            if (cachedRevision !== expectedRevision) {
                await staticCache.delete(request);
            }
        }));
        await serviceWorker.clients.claim();
    })());
});
serviceWorker.addEventListener("fetch", (event) => {
    const fetchEvent = event;
    const request = fetchEvent.request;
    const url = new URL(request.url);
    if (request.method !== "GET") {
        return;
    }
    if (url.pathname.startsWith("/functions/v1/inventory-search")) {
        fetchEvent.respondWith(cacheFirst(fetchEvent.request, INVENTORY_CACHE, 600000));
        return;
    }
    if (url.pathname.startsWith("/functions/v1/")) {
        fetchEvent.respondWith(networkFirst(fetchEvent.request, API_CACHE));
        return;
    }
    fetchEvent.respondWith(staleWhileRevalidate(fetchEvent.request, STATIC_CACHE));
});
async function cacheFirst(request, cacheName, maxAgeMs) {
    const cache = await caches.open(cacheName);
    const cached = await cache.match(request);
    if (cached) {
        const dateHeader = cached.headers.get("sw-fetched-at");
        if (dateHeader && Date.now() - Number(dateHeader) < maxAgeMs) {
            return cached;
        }
    }
    const response = await fetch(request);
    cache.put(request, stamp(response));
    return response;
}
async function networkFirst(request, cacheName) {
    const cache = await caches.open(cacheName);
    try {
        const response = await fetch(request);
        cache.put(request, stamp(response));
        return response;
    }
    catch (error) {
        const cached = await cache.match(request);
        if (cached)
            return cached;
        throw error;
    }
}
async function staleWhileRevalidate(request, cacheName) {
    const cache = await caches.open(cacheName);
    const cached = await cache.match(request);
    const networkPromise = fetch(request).then((response) => {
        cache.put(request, stamp(response));
        return response;
    });
    return cached || networkPromise;
}
function stamp(response, metadata) {
    const clone = response.clone();
    const headers = new Headers(clone.headers);
    headers.set("sw-fetched-at", Date.now().toString());
    if (metadata === null || metadata === void 0 ? void 0 : metadata.revision) {
        headers.set("sw-revision", metadata.revision);
    }
    return new Response(clone.body, {
        status: clone.status,
        statusText: clone.statusText,
        headers,
    });
}
