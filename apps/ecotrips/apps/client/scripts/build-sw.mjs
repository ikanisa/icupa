#!/usr/bin/env node
import { readFile, writeFile, readdir, stat } from "node:fs/promises";
import path from "node:path";
import crypto from "node:crypto";
import { fileURLToPath } from "node:url";
import { execFile } from "node:child_process";
import ts from "typescript";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const clientDir = path.resolve(__dirname, "..");
const publicDir = path.join(clientDir, "public");
const swSourcePath = path.join(publicDir, "sw.ts");
const swOutputPath = path.join(publicDir, "sw.js");

async function main() {
  const [version, manifest] = await Promise.all([
    resolveVersion(),
    buildPrecacheManifest(),
  ]);

  const source = await readFile(swSourcePath, "utf8");
  const manifestLiteral = JSON.stringify(manifest, null, 2);

  const transformedSource = source
    .replace(/"__BUILD_VERSION__"/g, JSON.stringify(version))
    .replace(
      /\/\* __PRECACHE_MANIFEST__ \*\/ \[\]/,
      `/* __PRECACHE_MANIFEST__ */ ${manifestLiteral}`,
    );

  const { outputText } = ts.transpileModule(transformedSource, {
    compilerOptions: {
      target: ts.ScriptTarget.ES2019,
      module: ts.ModuleKind.ES2015,
      sourceMap: false,
      removeComments: false,
    },
  });

  const banner = `// Generated by scripts/build-sw.mjs on ${new Date().toISOString()}\n`;
  await writeFile(swOutputPath, `${banner}${outputText}`);
  console.log(
    `Service worker built with version ${version} and ${manifest.length} precached assets.`,
  );
}

async function resolveVersion() {
  if (process.env.SW_BUILD_VERSION) {
    return process.env.SW_BUILD_VERSION;
  }

  try {
    const gitSha = await execFileAsync("git", ["rev-parse", "HEAD"], {
      cwd: clientDir,
    });
    return gitSha.trim();
  } catch (error) {
    if (error) {
      console.warn("Falling back to timestamp-based build version", error);
    }
    return `build-${Date.now()}`;
  }
}

async function buildPrecacheManifest() {
  const assetFiles = await collectAssetFiles();
  const manifestEntries = await Promise.all(
    assetFiles.map(async ({ filePath, urlPath }) => {
      const revision = await createFileHash(filePath);
      return { url: urlPath, revision };
    }),
  );
  return manifestEntries.sort((a, b) => a.url.localeCompare(b.url));
}

async function collectAssetFiles() {
  const results = [];

  await walkDirectory(publicDir, (fullPath) => {
    if (fullPath === path.join(publicDir, "sw.ts")) return false;
    if (fullPath === path.join(publicDir, "sw.js")) return false;
    const relative = path.relative(publicDir, fullPath).split(path.sep).join("/");
    results.push({ filePath: fullPath, urlPath: `/${relative}` });
    return true;
  });

  const nextStaticDir = path.join(clientDir, ".next", "static");
  if (await pathExists(nextStaticDir)) {
    await walkDirectory(nextStaticDir, (fullPath) => {
      const relative = path
        .relative(nextStaticDir, fullPath)
        .split(path.sep)
        .join("/");
      results.push({ filePath: fullPath, urlPath: `/_next/static/${relative}` });
      return true;
    });

    const buildIdPath = path.join(clientDir, ".next", "BUILD_ID");
    if (await pathExists(buildIdPath)) {
      results.push({ filePath: buildIdPath, urlPath: "/_next/BUILD_ID" });
    }
  }

  const uniqueByUrl = new Map(results.map((entry) => [entry.urlPath, entry]));
  return Array.from(uniqueByUrl.values()).sort((a, b) =>
    a.urlPath.localeCompare(b.urlPath),
  );
}

async function walkDirectory(dir, onFile) {
  let entries;
  try {
    entries = await readdir(dir);
  } catch (error) {
    if ((error)?.code === "ENOENT") {
      return;
    }
    throw error;
  }

  await Promise.all(
    entries.map(async (entry) => {
      const fullPath = path.join(dir, entry);
      const fileStat = await stat(fullPath);
      if (fileStat.isDirectory()) {
        await walkDirectory(fullPath, onFile);
        return;
      }
      onFile(fullPath);
    }),
  );
}

async function pathExists(targetPath) {
  try {
    await stat(targetPath);
    return true;
  } catch (error) {
    if ((error)?.code === "ENOENT") {
      return false;
    }
    throw error;
  }
}

async function createFileHash(filePath) {
  const hash = crypto.createHash("sha256");
  const fileBuffer = await readFile(filePath);
  hash.update(fileBuffer);
  return hash.digest("hex").slice(0, 16);
}

function execFileAsync(command, args, options) {
  return new Promise((resolve, reject) => {
    execFile(command, args, options, (error, stdout) => {
      if (error) {
        reject(error);
        return;
      }
      resolve(stdout);
    });
  });
}

main().catch((error) => {
  console.error("Failed to build service worker", error);
  process.exitCode = 1;
});
