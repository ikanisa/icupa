create schema if not exists comms;

create table if not exists comms.tm (
  id bigint generated by default as identity primary key,
  source_lang text not null check (source_lang = lower(source_lang) and source_lang <> ''),
  target_lang text not null check (target_lang = lower(target_lang) and target_lang <> ''),
  source_text text not null,
  target_text text not null,
  forward_hits bigint not null default 0 check (forward_hits >= 0),
  reverse_hits bigint not null default 0 check (reverse_hits >= 0),
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  constraint comms_tm_direction_unique unique (source_lang, target_lang, source_text)
);

comment on table comms.tm is 'Translation memory entries keyed by normalized language direction and source text.';
comment on column comms.tm.forward_hits is 'Number of forward direction lookups served from TM.';
comment on column comms.tm.reverse_hits is 'Number of reverse direction lookups served from TM.';

create or replace function comms.tm_set_updated_at()
returns trigger
language plpgsql
as $$
begin
  new.updated_at := now();
  return new;
end;
$$;

do $$
begin
  if not exists (
    select 1 from pg_trigger
    where tgname = 'comms_tm_updated_at'
  ) then
    create trigger comms_tm_updated_at
      before update on comms.tm
      for each row execute function comms.tm_set_updated_at();
  end if;
end;
$$;

create or replace function comms.direction_key(p_source text, p_target text)
returns text
language sql
stable
as $$
  select lower(coalesce(p_source, '')) || '>' || lower(coalesce(p_target, ''));
$$;

create or replace function comms.allowed_direction(p_source text, p_target text)
returns boolean
language plpgsql
stable
as $$
declare
  claims jsonb;
  directions jsonb;
  token text;
  forward_key text := comms.direction_key(p_source, p_target);
  reverse_key text := comms.direction_key(p_target, p_source);
begin
  if auth.role() = 'service_role' then
    return true;
  end if;

  claims := nullif(current_setting('request.jwt.claims', true), '')::jsonb;
  if claims is null then
    return false;
  end if;

  directions := claims -> 'tm_directions';
  if directions is null or jsonb_typeof(directions) <> 'array' then
    return false;
  end if;

  for token in
    select lower(elem)
    from jsonb_array_elements_text(directions) as t(elem)
  loop
    if token = forward_key or token = reverse_key then
      return true;
    end if;
  end loop;

  return false;
end;
$$;

create or replace function comms.upsert_tm_entry(
  p_source_lang text,
  p_target_lang text,
  p_source_text text,
  p_target_text text,
  p_increment_forward boolean default true,
  p_increment_reverse boolean default false
) returns comms.tm
language plpgsql
security definer
set search_path = comms, public
as $$
declare
  v_source text := lower(trim(coalesce(p_source_lang, '')));
  v_target text := lower(trim(coalesce(p_target_lang, '')));
  v_forward boolean := coalesce(p_increment_forward, true);
  v_reverse boolean := coalesce(p_increment_reverse, false);
  result comms.tm;
begin
  if v_source = '' or v_target = '' then
    raise exception 'source and target languages are required';
  end if;
  if p_source_text is null or length(p_source_text) = 0 then
    raise exception 'source_text is required';
  end if;
  if p_target_text is null or length(p_target_text) = 0 then
    raise exception 'target_text is required';
  end if;

  insert into comms.tm as t (
    source_lang,
    target_lang,
    source_text,
    target_text,
    forward_hits,
    reverse_hits
  ) values (
    v_source,
    v_target,
    p_source_text,
    p_target_text,
    case when v_forward then 1 else 0 end,
    case when v_reverse then 1 else 0 end
  )
  on conflict (source_lang, target_lang, source_text) do update
    set target_text = excluded.target_text,
        forward_hits = t.forward_hits + case when v_forward then 1 else 0 end,
        reverse_hits = t.reverse_hits + case when v_reverse then 1 else 0 end,
        updated_at = now()
  returning * into result;

  return result;
end;
$$;

grant usage on schema comms to authenticated;
grant select on table comms.tm to authenticated;

grant usage on schema comms to service_role;
grant select, insert, update, delete on table comms.tm to service_role;

grant execute on function comms.upsert_tm_entry(text, text, text, text, boolean, boolean) to service_role;

grant execute on function comms.direction_key(text, text) to authenticated;

grant execute on function comms.allowed_direction(text, text) to authenticated;

alter table comms.tm enable row level security;

do $$
begin
  if not exists (
    select 1 from pg_policies
    where schemaname = 'comms'
      and tablename = 'tm'
      and policyname = 'tm_select_direction'
  ) then
    create policy tm_select_direction on comms.tm
      for select using (comms.allowed_direction(source_lang, target_lang));
  end if;
end;
$$;

do $$
begin
  if not exists (
    select 1 from pg_policies
    where schemaname = 'comms'
      and tablename = 'tm'
      and policyname = 'tm_modify_direction'
  ) then
    create policy tm_modify_direction on comms.tm
      for all using (comms.allowed_direction(source_lang, target_lang))
      with check (comms.allowed_direction(source_lang, target_lang));
  end if;
end;
$$;
