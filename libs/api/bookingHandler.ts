/**
 * Example API handler for the Booking Agent
 * 
 * This demonstrates how to integrate the booking agent into an API endpoint
 * following the pattern described in the OpenAI Agents SDK blueprint.
 * 
 * This is an example implementation. For production use, this pattern should be
 * integrated into the agents-service/src/server.ts file.
 */

import type { FastifyInstance, FastifyRequest, FastifyReply } from 'fastify';
import { z } from 'zod';
import { BookingAgent, type BookingOutput } from '../agents/bookingAgent';
import { createAgentClient } from '../db/supabaseClient';
import type { BookingContext, AgentResponse } from '../types/agents';

/**
 * Request schema for booking agent endpoint
 */
const BookingRequestSchema = z.object({
  message: z.string().min(1).describe('User message or query'),
  session_id: z.string().optional().describe('Session ID to continue conversation'),
  tenant_id: z.string().describe('Tenant/organization identifier'),
  location_id: z.string().optional().describe('Location/venue identifier'),
  user_id: z.string().optional().describe('User identifier'),
  language: z.string().optional().describe('Preferred language for responses'),
  customer_email: z.string().email().optional().describe('Customer email if known'),
  customer_name: z.string().optional().describe('Customer name if known'),
});

type BookingRequest = z.infer<typeof BookingRequestSchema>;

/**
 * Mock runner for demonstration
 * In production, use the runner from agents-service/src/agents/agents.ts
 */
const mockRunner = {
  async run(agent: any, message: string, options: { context: BookingContext }) {
    // This is a simplified mock for demonstration
    // Real implementation uses @openai/agents runner
    return {
      sessionId: options.context.sessionId || `sess-${Date.now()}`,
      finalOutput: {
        reply: 'This is a mock response. In production, this would be generated by the agent.',
        bookings: [],
        next_steps: ['Check availability', 'Create booking'],
      },
      usage: {
        inputTokens: 100,
        outputTokens: 50,
      },
    };
  },
};

/**
 * Estimate cost based on token usage
 * GPT-4o pricing (as of 2025): $2.50 per 1M input tokens, $10.00 per 1M output tokens
 */
function estimateBookingCost(usage: { inputTokens: number; outputTokens: number }): number {
  const inputCostPer1M = 2.5; // $2.50 per 1M input tokens
  const outputCostPer1M = 10.0; // $10.00 per 1M output tokens

  const inputCost = (usage.inputTokens / 1_000_000) * inputCostPer1M;
  const outputCost = (usage.outputTokens / 1_000_000) * outputCostPer1M;

  return inputCost + outputCost;
}

/**
 * Build agent context from request
 */
function buildBookingContext(body: BookingRequest): BookingContext {
  return {
    sessionId: body.session_id,
    tenantId: body.tenant_id,
    userId: body.user_id,
    locationId: body.location_id,
    language: body.language || 'English',
    region: 'Rwanda', // Could be determined from location_id
    customerEmail: body.customer_email,
    customerName: body.customer_name,
  };
}

/**
 * Register booking agent routes
 * 
 * @param app - Fastify instance
 * 
 * @example
 * ```typescript
 * import Fastify from 'fastify';
 * import { registerBookingRoutes } from './libs/api/bookingHandler';
 * 
 * const app = Fastify();
 * registerBookingRoutes(app);
 * await app.listen({ port: 8787 });
 * ```
 */
export function registerBookingRoutes(app: FastifyInstance) {
  /**
   * POST /agents/booking
   * 
   * Main endpoint for booking agent interactions
   */
  app.post('/agents/booking', async (request: FastifyRequest, reply: FastifyReply) => {
    // Validate request body
    const parseResult = BookingRequestSchema.safeParse(request.body);
    if (!parseResult.success) {
      return reply.status(400).send({
        error: 'invalid_request',
        details: parseResult.error.issues,
      });
    }

    const body = parseResult.data;

    // Build agent context
    const context = buildBookingContext(body);

    // Create Supabase client for agent use
    const supabase = createAgentClient({
      tenantId: context.tenantId,
      userId: context.userId,
    });

    try {
      // Track start time
      const startTime = Date.now();

      // Run the booking agent
      // In production, use: import { runner } from 'agents-service/src/agents/agents';
      const result = await mockRunner.run(BookingAgent, body.message, { context });

      // Calculate execution time
      const executionTimeMs = Date.now() - startTime;

      // Extract usage and estimate cost
      const usage = result.usage || { inputTokens: 0, outputTokens: 0 };
      const costUsd = estimateBookingCost(usage);

      // Parse output
      const output = result.finalOutput as BookingOutput;

      // Log to database (in production)
      // await logAgentEvent({ ... });

      // Build response
      const response: AgentResponse<BookingOutput> = {
        sessionId: result.sessionId,
        output,
        costUsd: Number(costUsd.toFixed(6)),
        metadata: {
          model: 'gpt-4o',
          usage: {
            inputTokens: usage.inputTokens,
            outputTokens: usage.outputTokens,
          },
          executionTimeMs,
        },
      };

      return reply.send(response);
    } catch (error) {
      request.log.error({ err: error }, 'Booking agent execution failed');

      // Check for specific error types
      if (error instanceof Error) {
        if (error.message.includes('timeout')) {
          return reply.status(504).send({
            error: 'agent_timeout',
            message: 'Agent execution timed out. Please try again.',
          });
        }

        if (error.message.includes('budget')) {
          return reply.status(429).send({
            error: 'budget_exceeded',
            message: 'Agent budget limit exceeded. Please try again later.',
          });
        }
      }

      return reply.status(500).send({
        error: 'internal_error',
        message: 'An error occurred while processing your request.',
      });
    }
  });

  /**
   * GET /agents/booking/health
   * 
   * Health check for booking agent
   */
  app.get('/agents/booking/health', async (request: FastifyRequest, reply: FastifyReply) => {
    return reply.send({
      status: 'ok',
      agent: 'booking',
      features: {
        search_slots: true,
        create_booking: true,
        check_bookings: true,
      },
    });
  });
}

/**
 * Example usage in agents-service/src/server.ts:
 * 
 * ```typescript
 * import { registerBookingRoutes } from '../../libs/api/bookingHandler';
 * 
 * // ... existing code ...
 * 
 * // Register booking agent routes
 * registerBookingRoutes(app);
 * 
 * // ... rest of server setup ...
 * ```
 */

/**
 * Example curl request:
 * 
 * ```bash
 * curl -X POST http://localhost:8787/agents/booking \
 *   -H "Content-Type: application/json" \
 *   -d '{
 *     "message": "I want to book a table for 4 people on Friday evening",
 *     "tenant_id": "tenant-123",
 *     "location_id": "loc-456",
 *     "user_id": "user-789",
 *     "customer_email": "customer@example.com",
 *     "customer_name": "John Doe"
 *   }'
 * ```
 */
